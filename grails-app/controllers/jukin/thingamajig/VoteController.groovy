package jukin.thingamajig



import static org.springframework.http.HttpStatus.*
import grails.transaction.Transactional

@Transactional(readOnly = true)
class VoteController {

    static allowedMethods = [save: "POST", update: "PUT"]

    /**
     * Get votes per a repo, rendered in UI.
     * 
     * @param repoUrl
     * @return
     */
	def list(String repoUrl) {
		def found = Vote.findAllByRepoUrl(repoUrl)
		//respond found, view: 'index', model:[voteInstanceCount: found.count()]  // returns JSON
		render view: 'list', model:[voteInstanceList: found, voteInstanceCount: found?.size(), repoUrl: repoUrl ]  
    }

    /**
     * Get UI view for vote creation.
     * 
     * @return
     */
	def create() {
		render view: 'create', model: [voteInstance: new Vote(params)]
    }
	
	/**
	 * Specific action to be used from UI.
	 * Provides re-direction after saving completion.
	 *  
	 * @param voteInstance
	 * @return
	 */
	@Transactional
	def saveFromUI(Vote voteInstance) {
		
		log.debug "params: $params"
		log.debug "param Vote: $voteInstance"
		
		if (voteInstance == null) {
			notFound()
			return
		}

		if (voteInstance.hasErrors()) {
			respond voteInstance.errors, view:'create'
			return
		}

		voteInstance.save flush:true

		redirect action: 'list', params: [repoUrl: voteInstance.repoUrl]
	}


	/**
	 * Auto-generated by generate-views command.
	 */
	
	def index(Integer max) {
        params.max = Math.min(max ?: 10, 100)
       	respond Vote.list(params), model:[voteInstanceCount: Vote.count()]
    }

	def show(Vote voteInstance) {
        respond voteInstance
    }

	@Transactional
    def save(Vote voteInstance) {
		
        if (voteInstance == null) {
            notFound()
            return
        }

        if (voteInstance.hasErrors()) {
            respond voteInstance.errors, view:'create'
            return
        }

        voteInstance.save flush:true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.created.message', args: [message(code: 'vote.label', default: 'Vote'), voteInstance.id])
                redirect voteInstance
            }
            '*' { respond voteInstance, [status: CREATED] }
        }
    }

    @Transactional
    def update(Vote voteInstance) {
        if (voteInstance == null) {
            notFound()
            return
        }

        if (voteInstance.hasErrors()) {
            respond voteInstance.errors, view:'edit'
            return
        }

        voteInstance.save flush:true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.updated.message', args: [message(code: 'Vote.label', default: 'Vote'), voteInstance.id])
                redirect voteInstance
            }
            '*'{ respond voteInstance, [status: OK] }
        }
    }

	/*
	 def edit(Vote voteInstance) {
		 respond voteInstance
	 }
	 */
 
	/*
	 def create() {
		 respond new Vote(params)
	 }
	 */
 
    /*
	@Transactional
    def delete(Vote voteInstance) {

        if (voteInstance == null) {
            notFound()
            return
        }

        voteInstance.delete flush:true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.deleted.message', args: [message(code: 'Vote.label', default: 'Vote'), voteInstance.id])
                redirect action:"index", method:"GET"
            }
            '*'{ render status: NO_CONTENT }
        }
    }
    */

    protected void notFound() {
        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.not.found.message', args: [message(code: 'vote.label', default: 'Vote'), params.id])
                redirect action: "index", method: "GET"
            }
            '*'{ render status: NOT_FOUND }
        }
    }
}
